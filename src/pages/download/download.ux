<template>
	<div class="container">
		<scroll
			scroll-x="false"
			scroll-y="false"
			id="mask"
			if="{{ !showChapterSelect && global.screenShape == 'circle' && !downloadError }}"
		>
			<image
				style="top: 100px"
				src="/common/{{ processing ? 'success':'dling' }}_s4.png"
			></image>
		</scroll>
		<img
			if="{{ global.screenShape != 'circle' }}"
			class="leftButton top"
			src="/common/back.png"
			@click="routeBack"
		/>
		<text class="time">{{ time }}</text>

		<div class="title" style="justify-content: center">
			<text
				class="iconfont"
				style="margin-right: 10px"
				if="{{ global.screenShape == 'circle' }}"
			>
				&#xe685;
			</text>
			<marquee
				scrollamount="{{ 20 }}"
				text-offset="{{ 20 }}"
				style="font-size: 32px; font-weight: bold"
				@click="
					() => {
						if (global.screenShape == 'circle') {
							routeBack();
						}
					}
				"
			>
				{{ $t("download.title") }}{{ chapterName ? " - " + chapterName : "" }}
			</marquee>
		</div>

		<!-- 章节选择界面 -->
		<div class="chapter-select" if="{{ showChapterSelect && !downloadError }}">
			<scroll scroll-y="true" class="chapter-list" bounces="true">
				<div
					for="{{ chapter in chapterList }}"
					class="chapter-item {{ chapter.selected ? 'selected' : '' }}"
					@click="toggleChapter(chapter.num)"
				>
					<text class="chapter-text">{{ $t("photo.chapter") }}</text>
					<text class="chapter-text">{{ chapter.num }}</text>
				</div>
			</scroll>
			<div class="select-buttons">
				<div class="button" @click="selectAll">
					<text class="select-text">{{ $t("download.selectAll") }}</text>
				</div>
				<div class="button" @click="startBatchDownload">
					<text class="select-text">
						{{ $t("download.startDownload") }}({{ selectedChapters.length }})
					</text>
				</div>
			</div>
		</div>

		<!-- 方形手表下载界面 -->
		<div
			class="downloading"
			if="{{ !showChapterSelect && global.screenShape != 'circle' && !downloadError }}"
		>
			<image src="/common/{{ processing ? 'success':'dling' }}.png"></image>
			<text class="dl-text">
				{{ processing ? $t("download.complete") : $t("download.downloading") }}
			</text>
		</div>
		<div
			id="process"
			if="{{ !showChapterSelect && global.screenShape != 'circle' && !downloadError }}"
		>
			<text class="content">
				{{ $t("download.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<div
			class="downloading"
			if="{{ !showChapterSelect && global.screenShape != 'circle' && downloadError }}"
		>
			<image src="/common/fail.png"></image>
			<text class="dl-text">{{ downloadError }}</text>
		</div>

		<!-- 圆形手表下载界面 -->

		<div
			class="downloading"
			if="{{ !showChapterSelect && global.screenShape == 'circle' && !downloadError }}"
		>
			<text class="dl-text">
				{{ processing ? $t("download.complete") : $t("download.downloading") }}
			</text>
			<image src="/common/{{ processing ? 'success':'dl' }}_icon.png"></image>
		</div>
		<div
			id="process"
			if="{{ !showChapterSelect && global.screenShape == 'circle' && !downloadError }}"
		>
			<text class="content">
				{{ $t("download.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<image
			if="{{ !showChapterSelect && global.screenShape == 'circle' && downloadError }}"
			id="mask"
			src="/common/fail_s4.png"
		></image>
		<div
			class="downloading"
			if="{{ !showChapterSelect && global.screenShape == 'circle' && downloadError }}"
		>
			<text class="dl-text">{{ $t("download.downloadFailed") }}</text>
			<image src="/common/fail_icon.png"></image>
		</div>
		<div
			id="process-s4"
			if="{{ !showChapterSelect && global.screenShape == 'circle' && downloadError }}"
		>
			<text class="content">{{ downloadError }}</text>
		</div>
	</div>
</template>

<script>
import router from "@system.router";
import file from "@system.file";
import fetch from "@system.fetch";
import prompt from "@system.prompt";

const { getTime } = global;

let ImageCache = [];

function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

function sanitizeFolderName(name) {
	if (!name) return name;
	const invalidChars = /[\\/:*?"<>|]/g;
	return name.replace(invalidChars, "_");
}

function addImageParams(
	url,
	width = 600,
	quality = 50,
	params = ["width", "quality"]
) {
	try {
		const urlObj = new URL(url);
		urlObj.searchParams.set(params[0], width.toString());
		urlObj.searchParams.set(params[1], quality.toString());
		return urlObj.toString();
	} catch (error) {
		const separator = url.includes("?") ? "&" : "?";
		let result = url;
		if (!url.includes(params[0] + "=")) {
			result += `${separator}${params[0]}=${width}`;
		}
		if (!url.includes(params[1] + "=")) {
			result += "&" + params[1] + "=" + quality;
		}
		return result;
	}
}

export default {
	private: {
		time: "",
		id: 0,
		page_count: 0,
		name: "",
		page: 0,
		cover: "",
		processing: false,
		chapter: 0,
		downloadError: "",
		originalName: "",
		is_serial: false,
		showChapterSelect: false,
		chapterList: [],
		selectedChapters: [],
		total_chapters: 0,
		currentChapterIndex: 0,
		chapterName: "",
	},

	onShow() {
		this.time = getTime();
	},

	async onInit() {
		await this.initData();
		if (this.is_serial && this.total_chapters > 1) {
			this.showChapterSelect = true;
		} else {
			this.startDownloadProcess();
		}
	},

	async initData() {
		this.is_serial = this.total_chapters > 1;
		this.originalName = this.name;
		if (this.is_serial) {
			this.chapterList = [];
			for (let i = 1; i <= this.total_chapters; i++) {
				this.chapterList.push({
					num: i,
					selected: false,
				});
			}
		}
	},

	toggleChapter(chapterNum) {
		const index = this.selectedChapters.indexOf(chapterNum);
		if (index === -1) {
			this.selectedChapters.push(chapterNum);
		} else {
			this.selectedChapters.splice(index, 1);
		}
		for (let i = 0; i < this.chapterList.length; i++) {
			if (this.chapterList[i].num === chapterNum) {
				this.chapterList[i].selected = !this.chapterList[i].selected;
				break;
			}
		}
	},

	selectAll() {
		if (this.selectedChapters.length === this.total_chapters) {
			this.selectedChapters = [];
			for (let i = 0; i < this.chapterList.length; i++) {
				this.chapterList[i].selected = false;
			}
		} else {
			this.selectedChapters = [];
			for (let i = 1; i <= this.total_chapters; i++) {
				this.selectedChapters.push(i);
			}
			for (let i = 0; i < this.chapterList.length; i++) {
				this.chapterList[i].selected = true;
			}
		}
	},

	async startBatchDownload() {
		if (this.selectedChapters.length === 0) {
			prompt.showToast({
				message: this.$t("download.selectAtLeastOne"),
				duration: 2000,
			});
			return;
		}
		this.showChapterSelect = false;
		this.currentChapterIndex = 0;
		await this.downloadNextChapter();
	},

	async downloadNextChapter() {
		if (this.currentChapterIndex >= this.selectedChapters.length) {
			this.processing = true;
			prompt.showToast({
				message: this.$t("download.allComplete"),
				duration: 2000,
			});
			await sleep(1000);
			router.replace({
				uri: "/pages/offline",
			});
			return;
		}

		this.chapter = this.selectedChapters[this.currentChapterIndex];
		this.chapterName = "";
		this.processing = false;
		this.page = 0;
		this.downloadError = "";

		try {
			await this.startDownloadProcess();
			this.currentChapterIndex++;
			await sleep(500);
			await this.downloadNextChapter();
		} catch (error) {
			console.error(`章节 ${this.chapter} 下载失败:`, error);
			this.downloadError = error;
			this.processing = false;
		}
	},

	async startDownloadProcess() {
		try {
			const fileExists = await this.checkFileExists();

			if (fileExists) {
				await this.readAndUpdateComicsJson();
			} else {
				await this.createComicsJson();
			}

			await this.createFolderAndDownload();
		} catch (error) {
			console.log(`下载过程出错: ${error}`);
			this.downloadError = error;
			this.processing = false;
		}
	},

	checkFileExists() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: () => {
					resolve(true);
				},
				fail: (data, code) => {
					if (code === 301) {
						resolve(false);
					} else {
						reject(this.$t("download.checkFileFailed", { code: code }));
					}
				},
			});
		});
	},

	readAndUpdateComicsJson() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: (data) => {
					try {
						let comicsData = [];
						if (data.text) {
							comicsData = JSON.parse(data.text);
						}

						const newComic = {
							name: this.is_serial ? this.originalName : this.name,
							page_count: this.page_count,
							id: global.API_SETTING.using + "_" + this.id,
							is_serial: this.is_serial,
						};

						const existingIndex = comicsData.findIndex(
							(comic) => comic.id === newComic.id
						);
						if (existingIndex !== -1) {
							comicsData[existingIndex] = newComic;
						} else {
							comicsData.push(newComic);
						}

						file.writeText({
							uri: "internal://files/comics.json",
							text: JSON.stringify(comicsData),
							success: () => {
								console.log("comics.json 更新成功");
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.writeIndexFailed", { code: code }));
							},
						});
					} catch (parseError) {
						reject(this.$t("download.parseIndexFailed"));
					}
				},
				fail: (data, code) => {
					reject(this.$t("download.readIndexFailed", { code: code }));
				},
			});
		});
	},

	createComicsJson() {
		return new Promise((resolve, reject) => {
			const comicsData = [
				{
					name: this.is_serial ? this.originalName : this.name,
					page_count: this.page_count,
					id: global.API_SETTING.using + "_" + this.id,
					is_serial: this.is_serial,
				},
			];

			file.writeText({
				uri: "internal://files/comics.json",
				text: JSON.stringify(comicsData),
				success: () => {
					console.log("comics.json 创建成功");
					resolve();
				},
				fail: (data, code) => {
					reject(this.$t("download.createIndexFailed", { code: code }));
				},
			});
		});
	},

	async createFolderAndDownload() {
		try {
			this.processing = false;
			this.page = 0;
			this.downloadError = "";

			let folderUri;
			let coverUri;

			await this.DownloadImage();

			if (this.is_serial) {
				const mainFolderUri = `internal://files/${
					global.API_SETTING.using + "_" + this.id
				}`;
				await this.createFolder(mainFolderUri);
				const chapterName = sanitizeFolderName(this.chapterName || this.name);
				folderUri = `${mainFolderUri}/${this.chapter}　${chapterName}`;
				coverUri = mainFolderUri;
			} else {
				folderUri = `internal://files/${
					global.API_SETTING.using + "_" + this.id
				}`;
				coverUri = folderUri;
			}
			await this.createFolder(folderUri);

			if (this.currentChapterIndex === 0 || !this.is_serial) {
				await this.downloadCover(coverUri);
			}

			for (let i = 1; i <= this.page_count; i++) {
				this.page = i;
				await this.downloadImage(i, folderUri);
			}

			if (!this.is_serial) {
				this.processing = true;
				prompt.showToast({
					message: this.$t("download.complete"),
					duration: 2000,
				});

				await sleep(1000);
				router.replace({
					uri: "/pages/offline",
				});
			}
		} catch (error) {
			console.error("下载过程出错:", error);
			this.downloadError = error;
			this.processing = false;
			throw error;
		}
	},

	createFolder(folderUri) {
		return new Promise((resolve, reject) => {
			file.mkdir({
				uri: folderUri,
				success: () => {
					console.log(`创建文件夹成功: ${folderUri}`);
					resolve();
				},
				fail: (data, code) => {
					if (code === 13900001) {
						console.log("文件夹已存在");
						resolve();
					} else {
						reject(this.$t("download.createFolderFailed", { code: code }));
					}
				},
			});
		});
	},

	DownloadImage(retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			fetch.fetch({
				url:
					global.API_SETTING[global.API_SETTING.using].apiUrl +
					global.API_SETTING[global.API_SETTING.using].photoPath
						.replace("<id>", this.id)
						.replace("<chapter>", this.chapter),
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					const body = response.data;
					if (body.images_data) {
						ImageCache = [
							...body.images_data.data.picture.map(
								(img) =>
									global.API_SETTING[global.API_SETTING.using].apiUrl + img.url
							),
						];
						if (body.chapter_info && body.chapter_info.title) {
							this.chapterName = body.chapter_info.title;
						}
					} else {
						ImageCache = [...body.images.map((img) => img.url)];
						if (body.title) {
							this.chapterName = body.title;
						}
					}
					this.page_count = ImageCache.length;
					resolve();
				},
				fail: (data, code) => {
					console.log(
						`获取图片列表失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.fetchListTimeoutFailed"));
						} else {
							reject(this.$t("download.fetchListFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	downloadImage(page, folderUri, retryCount = 0) {
		let imageUrl;
		const MAX_RETRY = 3;

		return new Promise((resolve, reject) => {
			imageUrl = ImageCache[page - 1];
			imageUrl = addImageParams(
				imageUrl,
				parseInt(global.APP_SETTING.imageSize) || 600,
				parseInt(global.APP_SETTING.imageQuality) || 50
			);

			const fileUri = `${folderUri}/${page}`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: () => {
								console.log(`图片保存成功: ${fileUri}`);
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("download.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(
						`下载图片失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.downloadTimeoutFailed"));
						} else {
							reject(this.$t("download.downloadFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	downloadCover(folderUri, retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			let imageUrl;
			imageUrl = this.cover;

			const fileUri = `${folderUri}/cover`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: () => {
								console.log(`封面保存成功: ${fileUri}`);
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("download.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(
						`下载封面失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.coverTimeoutFailed"));
						} else {
							reject(this.$t("download.coverFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	routeBack() {
		router.back();
	},
};
</script>

<style>
@import "../../common/base.css";

.container {
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
}

.content {
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
}

.per {
	font-size: 32px;
	color: rgba(255, 255, 255, 0.6);
	font-weight: bold;
}

.dl-text {
	margin-top: 24px;
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
	margin-bottom: 80px;
	margin-left: 40px;
	margin-right: 40px;
}

/* 章节选择界面样式 */
.chapter-select {
	width: 100%;
	flex: 1;
	flex-direction: column;
	align-items: center;
	padding: 20px;
}

.chapter-list {
	width: 100%;
	flex: 1;
	flex-wrap: wrap;
	justify-content: space-between;
}

.chapter-item {
	width: 31%;
	background-color: #262626;
	border-radius: 12px;
	justify-content: center;
	align-items: center;
	margin-bottom: 10px;
	border: 3px solid rgba(255, 255, 255, 0.24);
	flex-direction: column;
}

.selected {
	background-color: #4caf50;
	border-color: #4caf50;
}

.chapter-text {
	font-size: 24px;
	color: #ffffff;
	font-weight: bold;
	text-align: center;
}

.select-text {
	font-size: 24px;
	color: #ffffff;
	font-weight: bold;
	text-align: center;
}

.select-buttons {
	margin-top: 20px;
	width: 100%;
	flex-direction: row;
	justify-content: space-between;
}

.button {
	min-width: 30%;
	border: 3px solid rgba(255, 255, 255, 0.24);
	background-color: #262626;
	padding: 10px 6px;
	border-radius: 100%;
	justify-content: center;
	align-items: center;
}

/* 方形手表适配 */
@media (shape: rect) {
	#process {
		position: absolute;
		bottom: 6px;
		width: 95%;
		height: 92px;
		background-color: #262626;
		border-radius: 36px;
		justify-content: space-around;
	}

	.downloading {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex: 1;
		flex-direction: column;
	}

	.select-buttons {
		width: 95%;
	}
}

/* 圆形手表适配 */
@media (min-width: 200) and (max-width: 235) and (shape: circle) {
	.container {
		justify-content: center;
	}

	.downloading {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex-direction: column;
		position: absolute;
		bottom: 40px;
	}

	.title {
		position: absolute;
		top: 32px;
	}

	.time {
		position: absolute;
		top: 10px;
	}

	#mask {
		position: absolute;
		height: 100%;
	}

	.dl-text {
		margin-top: 24px;
		font-size: 32px;
		color: #ffffff;
		font-weight: bold;
		margin-bottom: 20px;
	}

	#process {
		position: absolute;
		width: 80%;
		height: 92px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}

	#process-s4 {
		position: absolute;
		width: 80%;
		padding: 10px 25px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}

	.chapter-list {
		margin-top: 72px;
		width: 90%;
	}

	.select-buttons {
		flex-direction: column;
		width: 50%;
	}

	.button {
		margin-bottom: 10px;
		padding: 5px;
	}
}

/* 看看是不是小米手环Pro */
@media (device-type: band) and (shape: rect) {
	.title {
		width: 180px;
	}
}
/* 看看是不是红米手表 */
@media (device-type: watch) and (shape: rect) {
	.title {
		width: 248px;
	}
}

@media (device-type: watch) and (shape: circle) {
	.title {
		width: 240px;
	}
}
</style>
