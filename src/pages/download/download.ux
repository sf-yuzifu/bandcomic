<template>
	<div class="container">
		<img
			if="{{ global.screenShape != 'circle' }}"
			class="leftButton top"
			src="/common/back.png"
			@click="routeBack"
		/>
		<text class="time">{{ time }}</text>
		<text @click="routeBack" class="title">
			<span class="iconfont" if="{{ global.screenShape == 'circle' }}">
				&#xe685;
			</span>
			<span>{{ $t("download.title") }}</span>
		</text>

		<!-- 方形手表下载界面 -->
		<div
			class="downloading"
			if="{{ global.screenShape != 'circle' && !downloadError }}"
		>
			<image src="/common/{{ processing ? 'success':'dling' }}.png"></image>
			<text class="dl-text">
				{{ processing ? $t("download.complete") : $t("download.downloading") }}
			</text>
		</div>
		<div
			id="process"
			if="{{ global.screenShape != 'circle' && !downloadError }}"
		>
			<text class="content">
				{{ $t("download.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<div
			class="downloading"
			if="{{ global.screenShape != 'circle' && downloadError }}"
		>
			<image src="/common/fail.png"></image>
			<text class="dl-text">{{ downloadError }}</text>
		</div>

		<!-- 圆形手表下载界面 -->
		<image
			if="{{ global.screenShape == 'circle' && !downloadError }}"
			id="mask"
			src="/common/{{ processing ? 'success':'dling' }}_s4.png"
		></image>
		<div
			class="downloading"
			if="{{ global.screenShape == 'circle' && !downloadError }}"
		>
			<text class="dl-text">
				{{ processing ? $t("download.complete") : $t("download.downloading") }}
			</text>
			<image src="/common/{{ processing ? 'success':'dl' }}_icon.png"></image>
		</div>
		<div
			id="process"
			if="{{ global.screenShape == 'circle' && !downloadError }}"
		>
			<text class="content">
				{{ $t("download.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<image
			if="{{ global.screenShape == 'circle' && downloadError }}"
			id="mask"
			src="/common/fail_s4.png"
		></image>
		<div
			class="downloading"
			if="{{ global.screenShape == 'circle' && downloadError }}"
		>
			<text class="dl-text">{{ $t("download.downloadFailed") }}</text>
			<image src="/common/fail_icon.png"></image>
		</div>
		<div
			id="process-s4"
			if="{{ global.screenShape == 'circle' && downloadError }}"
		>
			<text class="content">{{ downloadError }}</text>
		</div>
	</div>
</template>

<script>
import router from "@system.router";
import file from "@system.file";
import fetch from "@system.fetch";
import prompt from "@system.prompt";

const { getTime } = global;

let ImageCache = [];

function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

function formatFileSize(size) {
	if (size < 1024) {
		return size + "B";
	} else if (size < 1024 * 1024) {
		return (size / 1024).toFixed(2) + "KB";
	} else if (size < 1024 * 1024 * 1024) {
		return (size / (1024 * 1024)).toFixed(2) + "MB";
	} else {
		return (size / (1024 * 1024 * 1024)).toFixed(2) + "GB";
	}
}

function sanitizeFolderName(name) {
	if (!name) return name;
	const invalidChars = /[\\/:*?"<>|]/g;
	return name.replace(invalidChars, "_");
}

function addImageParams(
	url,
	width = 600,
	quality = 50,
	params = ["width", "quality"]
) {
	try {
		const urlObj = new URL(url);
		urlObj.searchParams.set(params[0], width.toString());
		urlObj.searchParams.set(params[1], quality.toString());
		return urlObj.toString();
	} catch (error) {
		const separator = url.includes("?") ? "&" : "?";
		let result = url;
		if (!url.includes(params[0] + "=")) {
			result += `${separator}${params[0]}=${width}`;
		}
		if (!url.includes(params[1] + "=")) {
			result += "&" + params[1] + "=" + quality;
		}
		return result;
	}
}

export default {
	private: {
		time: "",
		id: 0,
		page_count: 0,
		name: "",
		page: 0,
		cover: "",
		processing: false,
		chapter: 0,
		downloadError: "",
		originalName: "",
		is_serial: false,
	},

	onShow() {
		this.time = getTime();
	},

	async onInit() {
		this.startDownloadProcess();
	},

	async startDownloadProcess() {
		try {
			// 1. 检查 comics.json 文件是否存在
			const fileExists = await this.checkFileExists();

			if (fileExists) {
				// 2. 如果存在，读取并更新 comics.json
				await this.readAndUpdateComicsJson();
			} else {
				// 3. 如果不存在，创建新的 comics.json 文件
				await this.createComicsJson();
			}

			// 4. 创建文件夹并开始下载图片
			await this.createFolderAndDownload();
		} catch (error) {
			console.log(`下载过程出错: ${error}`);
			this.downloadError = error;
			this.processing = false;
		}
	},

	checkFileExists() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: () => {
					resolve(true);
				},
				fail: (data, code) => {
					if (code === 301) {
						// 文件不存在
						resolve(false);
					} else {
						reject(this.$t("download.checkFileFailed", { code: code }));
					}
				},
			});
		});
	},

	readAndUpdateComicsJson() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: (data) => {
					try {
						let comicsData = [];
						if (data.text) {
							comicsData = JSON.parse(data.text);
						}

						const newComic = {
							name: this.is_serial ? this.originalName : this.name,
							page_count: this.page_count,
							id: global.API_SETTING.using + "_" + this.id,
							is_serial: this.is_serial,
						};

						const existingIndex = comicsData.findIndex(
							(comic) => comic.id === newComic.id
						);
						if (existingIndex !== -1) {
							comicsData[existingIndex] = newComic;
						} else {
							comicsData.push(newComic);
						}

						file.writeText({
							uri: "internal://files/comics.json",
							text: JSON.stringify(comicsData),
							success: () => {
								console.log("comics.json 更新成功");
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.writeIndexFailed", { code: code }));
							},
						});
					} catch (parseError) {
						reject(this.$t("download.parseIndexFailed"));
					}
				},
				fail: (data, code) => {
					reject(this.$t("download.readIndexFailed", { code: code }));
				},
			});
		});
	},

	createComicsJson() {
		return new Promise((resolve, reject) => {
			const comicsData = [
				{
					name: this.is_serial ? this.originalName : this.name,
					page_count: this.page_count,
					id: global.API_SETTING.using + "_" + this.id,
					is_serial: this.is_serial,
				},
			];

			file.writeText({
				uri: "internal://files/comics.json",
				text: JSON.stringify(comicsData),
				success: () => {
					console.log("comics.json 创建成功");
					resolve();
				},
				fail: (data, code) => {
					reject(this.$t("download.createIndexFailed", { code: code }));
				},
			});
		});
	},

	async createFolderAndDownload() {
		try {
			this.processing = false;
			this.page = 0;
			this.downloadError = "";

			let folderUri;
			let coverUri;

			if (this.is_serial) {
				const mainFolderUri = `internal://files/${
					global.API_SETTING.using + "_" + this.id
				}`;
				await this.createFolder(mainFolderUri);
				const chapterName = sanitizeFolderName(this.name);
				folderUri = `${mainFolderUri}/${this.chapter}　${chapterName}`;
				coverUri = mainFolderUri;
			} else {
				folderUri = `internal://files/${
					global.API_SETTING.using + "_" + this.id
				}`;
				coverUri = folderUri;
			}
			await this.createFolder(folderUri);

			await this.downloadCover(coverUri);

			await this.DownloadImage();

			for (let i = 1; i <= this.page_count; i++) {
				this.page = i;
				await this.downloadImage(i, folderUri);
			}

			this.processing = true;
			prompt.showToast({
				message: this.$t("download.complete"),
				duration: 2000,
			});

			await sleep(1000);
			router.replace({
				uri: "/pages/offline",
			});
		} catch (error) {
			console.error("下载过程出错:", error);
			this.downloadError = error;
			this.processing = false;
		}
	},

	createFolder(folderUri) {
		return new Promise((resolve, reject) => {
			file.mkdir({
				uri: folderUri,
				success: () => {
					console.log(`创建文件夹成功: ${folderUri}`);
					resolve();
				},
				fail: (data, code) => {
					if (code === 13900001) {
						console.log("文件夹已存在");
						resolve();
					} else {
						reject(this.$t("download.createFolderFailed", { code: code }));
					}
				},
			});
		});
	},

	DownloadImage(retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			fetch.fetch({
				url:
					global.API_SETTING[global.API_SETTING.using].apiUrl +
					global.API_SETTING[global.API_SETTING.using].photoPath
						.replace("<id>", this.id)
						.replace("<chapter>", this.chapter),
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					const body = response.data;
					// 检查响应格式并提取图片URL
					if (body.images_data) {
						ImageCache = [
							...body.images_data.data.picture.map(
								(img) =>
									global.API_SETTING[global.API_SETTING.using].apiUrl + img.url
							),
						];
					} else {
						ImageCache = [...body.images.map((img) => img.url)];
					}
					resolve();
				},
				fail: (data, code) => {
					console.log(
						`获取图片列表失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.fetchListTimeoutFailed"));
						} else {
							reject(this.$t("download.fetchListFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	downloadImage(page, folderUri, retryCount = 0) {
		let imageUrl;
		const MAX_RETRY = 3;

		return new Promise((resolve, reject) => {
			imageUrl = ImageCache[page - 1];
			imageUrl = addImageParams(
				imageUrl,
				parseInt(global.APP_SETTING.imageSize) || 600,
				parseInt(global.APP_SETTING.imageQuality) || 50
			);

			const fileUri = `${folderUri}/${page}`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: () => {
								console.log(`图片保存成功: ${fileUri}`);
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("download.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(
						`下载图片失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.downloadTimeoutFailed"));
						} else {
							reject(this.$t("download.downloadFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	downloadCover(folderUri, retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			let imageUrl;
			imageUrl = this.cover;

			const fileUri = `${folderUri}/cover`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				header: {
					"User-Agent": global.userAgent(),
				},
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: () => {
								console.log(`封面保存成功: ${fileUri}`);
								resolve();
							},
							fail: (data, code) => {
								reject(this.$t("download.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("download.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(
						`下载封面失败, code = ${code}, retryCount = ${retryCount}`
					);

					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.downloadTimeout", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("download.networkErrorRetry", {
								count: retryCount + 1,
							}),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("download.coverTimeoutFailed"));
						} else {
							reject(this.$t("download.coverFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	routeBack() {
		router.back();
	},
};
</script>

<style>
@import "../../common/base.css";

.container {
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
}

.content {
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
}

.per {
	font-size: 32px;
	color: rgba(255, 255, 255, 0.6);
	font-weight: bold;
}

.dl-text {
	margin-top: 24px;
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
	margin-bottom: 80px;
	margin-left: 40px;
	margin-right: 40px;
}

/* 方形手表适配 */
@media (shape: rect) {
	#process {
		position: absolute;
		bottom: 6px;
		width: 95%;
		height: 92px;
		background-color: #262626;
		border-radius: 36px;
		justify-content: space-around;
	}

	.downloading {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex: 1;
		flex-direction: column;
	}
}

/* 圆形手表适配 */
@media (min-width: 200) and (max-width: 235) and (shape: circle) {
	.container {
		justify-content: center;
	}

	.downloading {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex-direction: column;
		position: absolute;
		bottom: 40px;
	}

	.title {
		position: absolute;
		top: 35px;
	}

	.time {
		position: absolute;
		top: 7px;
	}

	#mask {
		position: absolute;
		top: 100px;
	}

	.dl-text {
		margin-top: 24px;
		font-size: 32px;
		color: #ffffff;
		font-weight: bold;
		margin-bottom: 20px;
	}

	#process {
		position: absolute;
		width: 80%;
		height: 92px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}

	#process-s4 {
		position: absolute;
		width: 80%;
		padding: 10px 25px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}
}
</style>
