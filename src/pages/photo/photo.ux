<template>
	<div class="demo-page">
		<img
			if="{{ showit && global.screenShape == 'circle' }}"
			src="/common/mask.png"
			class="leftButton"
		/>
		<img
			if="{{ showit&& global.screenShape == 'circle' }}"
			src="/common/mask.png"
			class="rightButton"
		/>
		<scroll
			style="{{ `align-items: ${images ? 'flex-start':'center'}; justify-content: ${images ?
'flex-start':'center'};` }}"
			id="scrollId"
			class="box"
			scroll-x="true"
			scroll-y="true"
			bounces="true"
			@scroll="onScroll"
		>
			<div @click="showButton" if="{{ images }}" class="padding"></div>
			<div
				if="{{ images }}"
				style="{{ `width:100%; height:${(global.screenSize.height - size.height * (1 + scale / 100
* 2))/ 2 + 2}px;` }}"
			></div>
			<image
				class="cover"
				src="{{ images }}"
				@complete="getPhoto"
				@error="
					() => {
						if (images != '') {
							loading = false;
							images = '';
						}
					}
				"
				@click="showButton"
				alt="{{ loading == 'end' ? '/common/end.png' : loading ? '/common/loading.png' :
'/common/error.png' }}"
				style="{{ `width:${size.width * (1 + scale / 100 * 2)}px;height:${size.height * (1 + scale
/ 100 * 2)}px;` }}"
			></image>
			<div
				if="{{ images }}"
				style="{{ `width:100%; height:${(global.screenSize.height - size.height * (1 + scale / 100
* 2))/ 2 + 2}px;` }}"
			></div>
			<div @click="showButton" if="{{ images }}" class="padding"></div>
		</scroll>

		<img
			if="{{ showit }}"
			src="/common/upCover.png"
			style="position: absolute; top: 0px; width: {{ global.screenSize.width }}px;"
		/>
		<img
			if="{{ showit }}"
			src="/common/bottomCover.png"
			style="position: absolute; bottom: 0px; width: {{ global.screenSize.width }}px;"
		/>

		<!-- 方表适配 -->
		<img
			if="{{ showit && global.screenShape != 'circle' }}"
			src="/common/left.png"
			onclick="toPage('-')"
			class="leftButton bottom"
		/>
		<img
			if="{{ showit && global.screenShape != 'circle' }}"
			src="/common/right.png"
			onclick="toPage('+')"
			class="rightButton bottom"
		/>

		<!-- 圆表适配 -->
		<img
			if="{{ showit && global.screenShape == 'circle' }}"
			src="/common/left_s4.png"
			onclick="toPage('-')"
			class="leftButton"
		/>
		<img
			if="{{ showit&& global.screenShape == 'circle' }}"
			src="/common/right_s4.png"
			onclick="toPage('+')"
			class="rightButton"
		/>

		<div class="com" if="{{ showSlider }}">
			<div class="shade">
				<div if="{{ total_chapters > 1 }}" class="chapter">
					<img src="/common/left.png" onclick="toChapter('-')" class="" />
					<marquee
						class="subtitle"
						scrollamount="{{ 20 }}"
						text-offset="{{ 20 }}"
					>
						{{ title }}
					</marquee>
					<img src="/common/right.png" onclick="toChapter('+')" class="" />
				</div>
				<text class="subtitle" if="{{ total_chapters > 1 }}">
					{{ $t("photo.chapterChange") }}
				</text>
				<div if="{{ total_chapters > 1 }}" style="height: 10px"></div>
				<div
					if="{{ total_chapters > 1 }}"
					style="
						flex-direction: row;
						justify-content: space-around;
						height: 40px;
					"
				>
					<picker
						for="pickerValue in pickerValues"
						type="text"
						style="width:{{ 80/pickerValues.length }}%; selected-font-size: 32px;"
						range="{{ pickerValue }}"
						selected="{{ chapter.toString().padStart(pickerValues.length, '0')[$idx] }}"
						onchange="onPickerChange($idx)"
					></picker>
				</div>
				<div if="{{ total_chapters > 1 }}" style="height: 20px"></div>
				<text class="subtitle">{{ $t("photo.photoSizeChange") }}</text>
				<div style="height: 10px"></div>
				<slider
					class="slider"
					min="0"
					max="100"
					step="1"
					value="{{ scale }}"
					onchange="onSliderChange"
				></slider>
				<div style="height: 10px"></div>
			</div>
		</div>

		<img
			if="{{ showit && global.screenShape != 'circle' }}"
			src="/common/left.png"
			@click="routeBack"
			class="leftButton top"
		/>
		<img
			if="{{ showit && global.screenShape != 'circle' }}"
			src="/common/more.png"
			class="rightButton top"
			@click="() => (showSlider = !showSlider)"
		/>
		<img
			if="{{ showit && global.screenShape == 'circle' }}"
			src="/common/check.png"
			class="bottom"
			@click="() => (showSlider = !showSlider)"
		/>

		<text class="time" if="{{ showit }}">{{ time }}</text>
		<text
			class="title"
			@click="
				() => {
					if (global.screenShape == 'circle') {
						routeBack();
					}
				}
			"
			if="{{ showit }}"
		>
			<span class="iconfont" if="{{ global.screenShape == 'circle' }}">
				&#xe685;
			</span>
			<span>
				{{ $t("photo.page", { page: page > page_count ? page_count : page }) }}
			</span>
		</text>
	</div>
</template>

<script>
import router from "@system.router";
import fetch from "@system.fetch";
import file from "@system.file";

const { screenSize, getTime } = global;

let ImageCache = [];
let originalName;

function addImageParams(
	url,
	width = 600,
	quality = 50,
	params = ["width", "quality"]
) {
	try {
		// 解析URL
		const urlObj = new URL(url);

		// 直接在主URL中添加参数
		urlObj.searchParams.set(params[0], width.toString());
		urlObj.searchParams.set(params[1], quality.toString());

		return urlObj.toString();
	} catch (error) {
		// URL解析失败，手动处理
		const separator = url.includes("?") ? "&" : "?";
		let result = url;

		// 确保不重复添加参数
		if (!url.includes(params[0] + "=")) {
			result += `${separator}${params[0]}=${width}`;
		}
		if (!url.includes(params[1] + "=")) {
			result += "&" + params[1] + "=" + quality;
		}

		return result;
	}
}

export default {
	private: {
		id: "",
		page_count: 0,
		page: 1,
		time: "",
		scale: 0,
		size: { width: 0, height: 0 },
		showit: true,
		showSlider: false,
		images: null,
		local: false,
		loading: true,
		title: "",
		chapter: 1,
		cover: "",
		total_chapters: 0,
		is_serial: false,
		downloadChapter: "",
		chapterList: [],
		pickerValues: [],
		hasReachedBottom: 0,
		hasReachedTop: 0,
		pos: [0, 0],
	},

	onShow() {
		this.time = getTime();
	},

	onBackPress() {
		return true;
	},

	onInit() {
		// 如果有传入的 source 参数，切换到对应的漫画源
		if (this.source) {
			global.API_SETTING.using = this.source;
		}

		// 读取历史记录，恢复上次阅读位置（本地和在线漫画都支持）
		const comicId = this.getComicId();
		file.readText({
			uri: "internal://files/history.json",
			success: (data) => {
				try {
					const historyList = JSON.parse(data.text);
					const historyItem = historyList.find((item) => item.id === comicId);
					if (historyItem) {
						// 恢复上次阅读的章节和页码
						this.chapter = historyItem.chapter || 1;
						this.page = historyItem.page || 1;
						console.log(
							`恢复阅读位置: 章节 ${this.chapter}, 页码 ${this.page}`
						);
					}
				} catch (e) {
					console.error("读取历史记录失败:", e);
				}
				this.initData();
			},
			fail: () => {
				// 没有历史记录，正常初始化
				this.initData();
			},
		});
	},

	initData() {
		if (!this.local) {
			originalName = this.title;
			this.is_serial = this.total_chapters > 1;
			if (this.is_serial) {
				this.chapterList = [];
				for (let i = 1; i <= this.total_chapters; i++) {
					this.chapterList.push(`${this.$t("photo.chapter")} ${i}`);
				}
				this.generatePickerRanges(this.total_chapters);
			}
		} else if (this.is_serial) {
			this.downloadChapter = JSON.parse(this.downloadChapter);
			this.total_chapters = this.downloadChapter.length;
			this.chapterList = this.downloadChapter.map((ch) => ch[0]);
			this.generatePickerRanges(this.total_chapters);
		}
		this.processData();
	},

	generatePickerRanges(total) {
		const values = [];
		const totalStr = total.toString();
		const digits = totalStr.length;

		for (let i = 0; i < digits; i++) {
			const digit = parseInt(totalStr[i]);
			const maxDigit = i === 0 ? digit : 9;
			const valueRange = [];
			for (let j = 0; j <= maxDigit; j++) {
				valueRange.push(j.toString());
			}
			values.push(valueRange);
		}
		this.pickerValues = values;
	},

	processData() {
		if (this.local) {
			this.getImageForPage();
		} else {
			this.fetchAllImageUrls();
		}
	},

	fetchAllImageUrls() {
		this.loading = true;
		this.images = "";
		this.scale = 0;
		this.size.width = screenSize.width / 2;
		this.size.height = screenSize.height / 2;
		const chapter = this.chapter;

		fetch.fetch({
			url:
				global.API_SETTING[global.API_SETTING.using].apiUrl +
				global.API_SETTING[global.API_SETTING.using].photoPath
					.replace("<id>", this.id)
					.replace("<chapter>", Math.floor(this.chapter)),
			header: {
				"User-Agent": global.userAgent(),
				...(global.cookie && global.cookie[global.API_SETTING.using]
					? { Cookie: global.cookie[global.API_SETTING.using] }
					: {}),
			},
			success: (response) => {
				if (chapter != this.chapter) {
					return;
				}
				const body = response.data;
				ImageCache = [...body.images.map((img) => img.url)];
				this.title = body.title;
				this.page_count = ImageCache.length;
				this.getImageForPage();
			},
			fail: (data, code) => {
				if (chapter != this.chapter) {
					return;
				}
				this.images = "internal://files/error.png";
				console.log(`handling fail, errMsg = ${data}`);
				console.log(`handling fail, errCode = ${code}`);
			},
		});
	},

	getImageForPage() {
		this.loading = true;
		this.images = "";
		this.scale = 0;
		this.size.width = screenSize.width / 2;
		this.size.height = screenSize.height / 2;

		if (this.page > this.page_count) {
			this.loading = "end";
			return;
		}

		const page = this.page;

		if (this.local) {
			if (this.is_serial) {
				const chapterNum = this.downloadChapter[this.chapter - 1][2];
				const chapterName = this.downloadChapter[this.chapter - 1][0];
				this.images = `internal://files/${this.id}/${chapterNum}　${chapterName}/${this.page}`;
				this.title = chapterName;
				this.page_count = this.downloadChapter[this.chapter - 1][1];
			} else {
				this.images = `internal://files/${this.id}/${this.page}`;
			}
			this.hasReachedBottom = 0;
			this.hasReachedTop = 0;
			this.pos = [0, 0];
			return;
		}

		let imageUrl = "";

		if (ImageCache.length > 0 && this.page <= ImageCache.length) {
			imageUrl = ImageCache[this.page - 1];
			imageUrl = addImageParams(
				imageUrl,
				parseInt(global.APP_SETTING.imageSize) || 600,
				parseInt(global.APP_SETTING.imageQuality) || 50
			);
		} else {
			return;
		}

		imageUrl += "#" + this.chapter;

		fetch.fetch({
			url: imageUrl,
			responseType: "file",
			header: {
				"User-Agent": global.userAgent(),
				...(global.cookie && global.cookie[global.API_SETTING.using]
					? { Cookie: global.cookie[global.API_SETTING.using] }
					: {}),
			},
			success: (response) => {
				if (page != this.page) {
					return;
				}
				this.images = response.data;
				this.hasReachedBottom = 0;
				this.hasReachedTop = 0;
				this.pos = [0, 0];
			},
			fail: () => {
				if (page != this.page) {
					return;
				}
				this.images = "internal://files/error.png";
			},
		});
	},

	routeBack() {
		router.back();
	},

	toChapter(value) {
		switch (value) {
			case "+":
				if (this.chapter < this.total_chapters) {
					this.chapter += 1;
				}
				break;
			case "-":
				if (this.chapter > 1) {
					this.chapter -= 1;
				}
				break;
		}
		this.$element("scrollId").scrollTo({
			top: 1,
			left: 0,
		});
		this.page = 1;
		this.processData();
		this.saveHistory();
	},

	toPage(value) {
		switch (value) {
			case "+":
				if (this.page <= this.page_count) {
					this.page += 1;
				}
				break;
			case "-":
				if (this.page > 1) {
					this.page -= 1;
				}
				break;
		}
		this.$element("scrollId").scrollTo({
			top: 1,
			left: 0,
		});
		this.getImageForPage();
		this.saveHistory();
	},

	getPhoto(value) {
		this.size.width = screenSize.width;
		this.size.height = (screenSize.width / value.width) * value.height;
	},

	// 获取漫画ID（区分本地和在线）
	getComicId() {
		if (this.local) {
			// 本地漫画使用 local_ 前缀
			return "local_" + this.id;
		} else {
			// 在线漫画使用 online_ 前缀
			return "online_" + global.API_SETTING.using + "_" + this.id;
		}
	},

	// 保存阅读历史
	saveHistory() {
		const comicId = this.getComicId();
		const historyData = {
			id: comicId,
			originalId: this.id,
			title: this.is_serial && originalName ? originalName : this.title,
			cover: this.cover,
			chapter: this.chapter,
			page: this.page > this.page_count ? this.page_count : this.page,
			total_chapters: this.total_chapters,
			page_count: this.page_count,
			is_serial: this.is_serial,
			local: this.local,
			source: this.local ? null : global.API_SETTING.using,
			last_read_time: Date.now(),
		};

		// 读取现有历史记录
		file.readText({
			uri: "internal://files/history.json",
			success: (data) => {
				let historyList = [];
				try {
					historyList = JSON.parse(data.text);
					if (!Array.isArray(historyList)) {
						historyList = [];
					}
				} catch (e) {
					historyList = [];
				}

				// 查找是否已存在该漫画的记录
				const existingIndex = historyList.findIndex(
					(item) => item.id === comicId
				);

				if (existingIndex !== -1) {
					// 更新现有记录
					historyList[existingIndex] = historyData;
					// 移到最前面
					historyList.splice(existingIndex, 1);
					historyList.unshift(historyData);
				} else {
					// 添加新记录到最前面
					historyList.unshift(historyData);
				}

				// 限制历史记录数量（最多50条）
				if (historyList.length > 50) {
					historyList = historyList.slice(0, 50);
				}

				// 保存回文件
				file.writeText({
					uri: "internal://files/history.json",
					text: JSON.stringify(historyList, null, 2),
					success: () => {
						console.log("历史记录保存成功");
					},
					fail: (data, code) => {
						console.error("保存历史记录失败:", code);
					},
				});
			},
			fail: () => {
				// 文件不存在，创建新文件
				const historyList = [historyData];
				file.writeText({
					uri: "internal://files/history.json",
					text: JSON.stringify(historyList, null, 2),
					success: () => {
						console.log("历史记录创建成功");
					},
					fail: (data, code) => {
						console.error("创建历史记录失败:", code);
					},
				});
			},
		});
	},

	showButton() {
		this.showit = !this.showit;
	},

	onPickerChange(pickerIndex, e) {
		const chapterStr = this.chapter
			.toString()
			.padStart(this.pickerValues.length, "0");
		const newDigits = [...chapterStr];
		newDigits[pickerIndex] = e.newValue;

		let newChapter = parseInt(newDigits.join(""));

		if (newChapter > this.total_chapters) {
			newChapter = this.total_chapters;
		}
		if (newChapter < 1) {
			newChapter = 1;
		}
		this.chapter = newChapter;

		this.updatePickerRanges();

		if (this.local) {
			this.title = this.downloadChapter[this.chapter - 1][0];
		} else {
			this.title = `${this.$t("photo.chapter")} ${this.chapter}`;
		}
		this.$element("scrollId").scrollTo({
			top: 1,
			left: 0,
		});
		this.page = 1;
		this.processData();
		this.saveHistory();
	},

	updatePickerRanges() {
		const values = [];
		const totalStr = this.total_chapters.toString();
		const digits = totalStr.length;
		const chapterStr = this.chapter.toString().padStart(digits, "0");

		for (let i = 0; i < digits; i++) {
			const digit = parseInt(totalStr[i]);
			const valueRange = [];

			if (i === 0) {
				for (let j = 0; j <= digit; j++) {
					valueRange.push(j.toString());
				}
			} else {
				let maxDigit = 9;
				for (let k = 0; k < i; k++) {
					if (parseInt(chapterStr[k]) < parseInt(totalStr[k])) {
						maxDigit = 9;
						break;
					} else if (parseInt(chapterStr[k]) > parseInt(totalStr[k])) {
						maxDigit = 0;
						break;
					} else if (k === i - 1) {
						maxDigit = digit;
					}
				}
				for (let j = 0; j <= maxDigit; j++) {
					valueRange.push(j.toString());
				}
			}
			values.push(valueRange);
		}
		this.pickerValues = values;
	},

	onSliderChange(e) {
		this.scale = e.progress;
		this.$element("scrollId").scrollTo({
			top: 1,
			left: 0,
		});
		this.hasReachedBottom = 0;
		this.hasReachedTop = 0;
		this.pos = [0, 0];
	},

	async onScroll(val) {
		if (!this.images) {
			// console.log(this.images);
			return;
		}
		if (this.pos[1] == val.scrollY) {
			// console.log(this.pos[1], val.scrollY);
			this.pos[0] = val.scrollX;
			return;
		}
		if (this.pos[0] != val.scrollX) {
			// console.log(this.pos[0], val.scrollX);
			this.pos[1] = val.scrollY;
			return;
		}
		// if (val.scrollX < 0 && val.scrollY == 0) return;
		this.pos = [val.scrollX, val.scrollY];
		const self = this;
		this.$element("scrollId").getScrollRect({
			success({ width, height }) {
				if (val.scrollX + global.screenSize.width > width) return;
				if (val.scrollY + global.screenSize.height >= height) {
					if (val.scrollY + global.screenSize.height == height) {
						if (self.hasReachedBottom > 0) {
							self.toPage("+");
						} else {
							self.hasReachedBottom++;
							self.hasReachedTop = 0;
							// console.log("到底部了1", self.hasReachedBottom);
						}
					} else {
						// console.log("到底部了", self.hasReachedBottom);
					}
				} else if (val.scrollY <= 0) {
					if (val.scrollY == 0) {
						if (self.hasReachedTop > 0) {
							self.toPage("-");
						} else {
							self.hasReachedTop++;
							self.hasReachedBottom = 0;
							// console.log("到顶部了1", self.hasReachedTop);
						}
					} else {
						// console.log("到顶部了", self.hasReachedTop);
					}
				}
			},
		});
	},
};
</script>

<style>
@import "../../common/base.css";

.demo-page {
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	color: #ffffff;
	height: 100%;
}

.box {
	position: relative;
	width: 100%;
	height: 100%;
	flex-direction: column;
}

text {
	font-size: 20px;
}

.button {
	height: 50px;
	font-size: 25px;
	color: white;
}

.com {
	position: absolute;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
}

.title {
	position: absolute;
	top: 32px;
}

.time {
	position: absolute;
	top: 10px;
}

.slider {
	width: 100%;
}

.shade {
	background-color: rgba(38, 38, 38, 0.6);
	border-radius: 36px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	width: 90%;
	padding: 20px 10px;
	border: 3px rgba(255, 255, 255, 0.24);
}

.chapter {
	align-items: center;
	justify-content: space-between;
	width: 100%;
	margin-bottom: 20px;
}

.subtitle {
	display: flex;
	justify-items: center;
	align-items: center;
	font-size: 24px;
	width: 75%;
	text-align: center;
	font-weight: bold;
	color: rgba(255, 255, 255, 1);
}

.dl {
	border-radius: 100%;
	border: 3px rgba(255, 255, 255, 0.24);
	background-color: #262626;
	padding: 10px;
}

/* 看看是不是小米手表 */
@media (device-type: watch) and (shape: circle) {
	.padding {
		height: 50%;
	}

	.leftButton {
		left: 6px;
	}

	.rightButton {
		right: 6px;
	}

	.bottom {
		position: absolute;
		bottom: 6px;
	}
	.shade {
		width: 75%;
	}
}

/* 看看是不是小米手表 */
@media (min-width: 200) and (max-width: 235) and (shape: circle) {
	.leftButton {
		top: 182px;
	}

	.rightButton {
		top: 182px;
	}

	.bottom {
		left: 182px;
	}
}

/* 看看是不是小米手表s1 pro */
@media (min-width: 235) and (max-width: 250) and (shape: circle) {
	.leftButton {
		top: 189px;
	}

	.rightButton {
		top: 189px;
	}

	.bottom {
		left: 189px;
	}
}

/* 看看是不是红米手表 */
@media (device-type: watch) and (shape: rect) {
	.padding {
		height: 10%;
	}
}
</style>
