<template>
	<div class="container">
		<img
			if="{{ global.screenShape != 'circle' }}"
			class="leftButton top"
			src="/common/back.png"
			@click="routeBack"
		/>
		<text class="time">{{ time }}</text>
		<text
			@click="
				() => {
					if (global.screenShape == 'circle') {
						routeBack();
					}
				}
			"
			class="title"
		>
			<span class="iconfont" if="{{ global.screenShape == 'circle' }}">
				&#xe685;
			</span>
			<span>{{ $t("offline.offline") }}</span>
		</text>
		<div
			style="height: 78px"
			if="{{ !dl && global.screenShape == 'circle' }}"
		></div>
		<div if="{{ !dl && storageLoaded }}" class="storage-container">
			<text class="storage-label">{{ $t("offline.storage") }}</text>
			<div class="storage-bar">
				<div class="storage-bar-segment-reserved" style="width: {{ systemReservedPercent }}%"></div>
				<div class="storage-bar-segment-comics" style="width: {{ comicsUsedPercent }}%"></div>
				<div class="storage-bar-segment-other" style="width: {{ actualUsedPercent - comicsUsedPercent }}%"></div>
			</div>
			<div class="storage-list">
				<div class="storage-list-item" @click="toggleStorageList">
					<div class="storage-list-color storage-list-color-remaining"></div>
					<text class="storage-list-label">{{ $t("offline.remaining") }}</text>
					<text class="storage-list-value">{{ remaining }}</text>
					<text class="storage-list-arrow">{{ storageListExpanded ? '&#xe686' : '&#xe685' }}</text>
				</div>
				<div if="{{ storageListExpanded }}" class="storage-list-item">
					<div class="storage-list-color storage-list-color-reserved"></div>
					<text class="storage-list-label">{{ $t("offline.legendReserved") }}</text>
					<text class="storage-list-value">{{ systemReserved }}</text>
					<text class="storage-list-arrow" style="opacity: 0;">&#xe686</text>
				</div>
				<div if="{{ storageListExpanded }}" class="storage-list-item">
					<div class="storage-list-color storage-list-color-comics"></div>
					<text class="storage-list-label">{{ $t("offline.comicsUsed") }}</text>
					<text class="storage-list-value">{{ comicsUsed }}</text>
					<text class="storage-list-arrow" style="opacity: 0;">&#xe686</text>
				</div>
				<div if="{{ storageListExpanded }}" class="storage-list-item">
					<div class="storage-list-color storage-list-color-other"></div>
					<text class="storage-list-label">{{ $t("offline.otherUsed") }}</text>
					<text class="storage-list-value">{{ otherUsed }}</text>
					<text class="storage-list-arrow" style="opacity: 0;">&#xe686</text>
				</div>
			</div>
		</div>
		<div style="height: 10px" if="{{ !dl }}"></div>
		<list if="{{ !dl && comicsList.length != 0 }}" class="box" bounces="true">
			<list-item for="{{ comicsList }}" class="item" type="list-item">
				<image
					@click="toPhoto($item)"
					class="cover"
					src="internal://files/{{ $item.id }}/cover"
				></image>
				<div @click="toPhoto($item)" class="text-content">
					<text class="itemText">{{ $item.name }}</text>
					<text class="meta">{{ $t("offline.size") }} {{ $item.size }}</text>
				</div>
				<image src="/common/del.png" @click="del($item.id)"></image>
			</list-item>
		</list>
		<div class="downloading" if="{{ dl && global.screenShape != 'circle' && !downloadError }}">
			<image src="/common/{{ processing ? 'success':'dling' }}.png"></image>
			<text class="dl-text">
				{{ processing ? $t("offline.complete") : $t("offline.downloading") }}
			</text>
		</div>
		<div id="process" if="{{ dl && global.screenShape != 'circle' && !downloadError }}">
			<text class="content">
				{{ $t("offline.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<div class="downloading" if="{{ dl && global.screenShape != 'circle' && downloadError }}">
			<image src="/common/fail.png"></image>
			<text class="dl-text">{{ downloadError }}</text>
		</div>

		<image
			if="{{ dl && global.screenShape == 'circle' && !downloadError }}"
			id="mask"
			src="/common/{{ processing ? 'success':'dling' }}_s4.png"
		></image>
		<div class="downloading" if="{{ dl && global.screenShape == 'circle' && !downloadError }}">
			<text class="dl-text">
				{{ processing ? $t("offline.complete") : $t("offline.downloading") }}
			</text>
			<image src="/common/{{ processing ? 'success':'dl' }}_icon.png"></image>
		</div>
		<div id="process" if="{{ dl && global.screenShape == 'circle' && !downloadError }}">
			<text class="content">
				{{ $t("offline.page", { page: page, total_page: page_count }) }}
			</text>
			<text class="per">{{ Math.floor((page / page_count) * 100) }}%</text>
		</div>
		<image
			if="{{ dl && global.screenShape == 'circle' && downloadError }}"
			id="mask"
			src="/common/fail_s4.png"
		></image>
		<div class="downloading" if="{{ dl && global.screenShape == 'circle' && downloadError }}">
			<text class="dl-text">{{ $t("offline.downloadFailedText") }}</text>
			<image src="/common/fail_icon.png"></image>
		</div>
		<div id="process-s4" if="{{ dl && global.screenShape == 'circle' && downloadError }}">
			<text class="content">{{ downloadError }}</text>
		</div>

		<div class="empty" if="{{ comicsList.length == 0 && !dl }}">
			<image src="/common/empty.png"></image>
			<text class="empty-text">{{ isLoading ? $t("offline.loading") : $t("offline.empty") }}</text>
		</div>
	</div>
</template>

<script>
import router from "@system.router"
import file from "@system.file";
import fetch from "@system.fetch";
import prompt from "@system.prompt";
import device from "@system.device";

const { getTime } = global;

let del;
let ehImageCache = [];
let ImageCache = [];

function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

function formatFileSize(size) {
	if (size < 1024) {
		return size + "B";
	} else if (size < 1024 * 1024) {
		return (size / 1024).toFixed(2) + "KB";
	} else if (size < 1024 * 1024 * 1024) {
		return (size / (1024 * 1024)).toFixed(2) + "MB";
	} else {
		return (size / (1024 * 1024 * 1024)).toFixed(2) + "GB";
	}
}

function addImageParams(
	url,
	width = 600,
	quality = 50,
	params = ["width", "quality"]
) {
	try {
		// 解析URL
		const urlObj = new URL(url);

		// 直接在主URL中添加参数
		urlObj.searchParams.set(params[0], width.toString());
		urlObj.searchParams.set(params[1], quality.toString());

		return urlObj.toString();
	} catch (error) {
		// URL解析失败，手动处理
		const separator = url.includes("?") ? "&" : "?";
		let result = url;

		// 确保不重复添加参数
		if (!url.includes(params[0] + "=")) {
			result += `${separator}${params[0]}=${width}`;
		}
		if (!url.includes(params[1] + "=")) {
			result += "&" + params[1] + "=" + quality;
		}

		return result;
	}
}

export default {
	private: {
		time: "",
		dl: false,
		id: 0,
		page_count: 0,
		name: "",
		comicsList: [],
		page: 0,
		cover: "",
		processing: false,
		storage: "",
		storagePercent: 0,
		storageUsed: "",
		storageTotal: "",
		systemReserved: "",
		actualTotal: "",
		systemReservedPercent: 25,
		actualUsedPercent: 0,
		comicsUsed: "",
		comicsUsedPercent: 0,
		otherUsed: "",
		remaining: "",
		storageListExpanded: false,
		storageLoaded: false,
		isLoading: false,
		chapter: 0,
		downloadError: "",
	},

	onShow() {
		this.time = getTime();
	},

	async onInit() {
		if (this.dl) {
			this.startDownloadProcess();
		} else {
			this.loadingComic();
		}
	},

	async loadingComic() {
		this.isLoading = true;
		// 1. 检查comics.json文件是否存在
		const fileExists = await this.checkFileExists();

		if (fileExists) {
			file.readText({
				uri: "internal://files/comics.json",
				success: (data) => {
					try {
						let comicsData = [];
						if (data.text) {
							comicsData = JSON.parse(data.text);
						}
						this.comicsList = comicsData;
						this.getStorage();
					} catch (parseError) {
						console.log(`解析comics.json失败: ${parseError}`);
					}
					this.isLoading = false;
				},
				fail: function (data, code) {
					console.log(`读取comics.json失败, code = ${code}`);
					this.isLoading = false;
				},
			});
		} else {
			this.isLoading = false;
		}
	},

	getStorage() {
		let totalStorage = 0;
		let availableStorage = 0;
		let comicsTotalSize = 0;
		let completedCount = 0;
		
		device.getTotalStorage({
			success: (data) => {
				totalStorage = data.totalStorage;
				const systemReserved = Math.floor(totalStorage / 4);
				const actualTotal = totalStorage - systemReserved;
				
				this.storageTotal = formatFileSize(totalStorage);
				this.systemReserved = formatFileSize(systemReserved);
				this.actualTotal = formatFileSize(actualTotal);
				
				if (availableStorage > 0) {
					this.updateStorageDisplay(actualTotal, availableStorage, comicsTotalSize);
				}
			},
			fail: (data, code) => {
				console.log(`获取总存储空间失败, code = ${code}`);
			},
		});
		
		device.getAvailableStorage({
			success: (data) => {
				availableStorage = data.availableStorage;
				this.storage = formatFileSize(availableStorage);
				
				if (totalStorage > 0) {
					const systemReserved = Math.floor(totalStorage / 4);
					const actualTotal = totalStorage - systemReserved;
					this.updateStorageDisplay(actualTotal, availableStorage, comicsTotalSize);
				}
			},
			fail: (data, code) => {
				console.log(`获取可用存储空间失败, code = ${code}`);
			},
		});
		
		for (let a = 0; a < this.comicsList.length; a++) {
			file.get({
				uri: `internal://files/${this.comicsList[a].id}`,
				recursive: true,
				success: (data) => {
					let length = 0;
					for (let i of data.subFiles) {
						length += i.length;
					}
					this.comicsList[a].size = formatFileSize(length);
					comicsTotalSize += length;
					this.comicsUsed = formatFileSize(comicsTotalSize);
					console.log("大小：", this.comicsList[a].size);
					
					completedCount++;
					if (completedCount === this.comicsList.length && totalStorage > 0) {
						const systemReserved = Math.floor(totalStorage / 4);
						const actualTotal = totalStorage - systemReserved;
						this.comicsUsedPercent = Math.floor((comicsTotalSize / actualTotal) * 100);
					}
				},
				fail: function (data, code) {
					console.log(`handling fail, code = ${code}`);
					completedCount++;
				},
			});
		}
	},

	updateStorageDisplay(actualTotal, availableStorage, comicsTotalSize) {
		this.storageUsed = formatFileSize(actualTotal - availableStorage);
		this.actualUsedPercent = Math.floor(
			((actualTotal - availableStorage) / actualTotal) * 100
		);
		this.comicsUsed = formatFileSize(comicsTotalSize);
		this.comicsUsedPercent = Math.floor((comicsTotalSize / actualTotal) * 100);
		this.otherUsed = formatFileSize(actualTotal - availableStorage - comicsTotalSize);
		this.remaining = formatFileSize(availableStorage);
		this.storageLoaded = true;
	},

	async startDownloadProcess() {
		try {
			// 1. 检查comics.json文件是否存在
			const fileExists = await this.checkFileExists();

			if (fileExists) {
				// 2. 读取并更新comics.json
				await this.readAndUpdateComicsJson();
			} else {
				// 3. 创建新的comics.json文件
				await this.createComicsJson();
			}

			// 4. 创建文件夹并下载图片
			await this.createFolderAndDownload();
		} catch (error) {
			console.log(`下载过程出错: ${error}`);
		}
	},

	checkFileExists() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: function () {
					resolve(true);
				},
				fail: function (data, code) {
					if (code === 301) {
						// 文件不存在
						resolve(false);
					} else {
						reject(this.$t("offline.checkFileFailed", { code: code }));
					}
				},
			});
		});
	},

	readAndUpdateComicsJson() {
		return new Promise((resolve, reject) => {
			file.readText({
				uri: "internal://files/comics.json",
				success: (data) => {
					try {
						let comicsData = [];
						if (data.text) {
							comicsData = JSON.parse(data.text);
						}

						// 添加新的漫画信息
						const newComic = {
							name: this.name,
							page_count: this.page_count,
							id: this.id + (this.chapter ? "_" + this.chapter : ""),
						};

						// 检查是否已存在相同id的漫画
						const existingIndex = comicsData.findIndex(
							(comic) => comic.id === newComic.id
						);
						if (existingIndex !== -1) {
							comicsData[existingIndex] = newComic;
						} else {
							comicsData.push(newComic);
						}

						// 写回文件
						file.writeText({
							uri: "internal://files/comics.json",
							text: JSON.stringify(comicsData),
							success: function () {
								console.log("comics.json更新成功");
								resolve();
							},
							fail: function (data, code) {
								reject(this.$t("offline.writeIndexFailed", { code: code }));
							},
						});
					} catch (parseError) {
						reject(this.$t("offline.parseIndexFailed"));
					}
				},
				fail: function (data, code) {
					reject(this.$t("offline.readIndexFailed", { code: code }));
				},
			});
		});
	},

	createComicsJson() {
		return new Promise((resolve, reject) => {
			const initialData = [
				{
					name: this.name,
					page_count: this.page_count,
					id: this.id + this.chapter ? "_" + this.chapter : "",
				},
			];

			file.writeText({
				uri: "internal://files/comics.json",
				text: JSON.stringify(initialData),
				success: function () {
					console.log("comics.json创建成功");
					resolve();
				},
				fail: function (data, code) {
					reject(this.$t("offline.createIndexFailed", { code: code }));
				},
			});
		});
	},

	async createFolderAndDownload() {
		try {
			const folderUri = `internal://files/${
				this.id + (this.chapter ? "_" + this.chapter : "")
			}`;
			await this.createFolder(folderUri);

			await this.downloadCover(folderUri);

			if (global.API_SETTING[global.API_SETTING.using].type === "jmcomic") {
				for (let page = 1; page <= this.page_count; page++) {
					this.page = page;
					await this.downloadImage(page, folderUri);
				}
			} else if (
				global.API_SETTING[global.API_SETTING.using].type === "ehentai"
			) {
				await this.ehDownloadImage();
				for (let page = 1; page <= this.page_count; page++) {
					this.page = page;
					await this.downloadImage(page, folderUri);
				}
				for (let i = 0; i < ehImageCache.length; i++) {
					this.page = i + 1;
					try {
						await new Promise((resolve, reject) => {
							fetch.fetch({
								url: ehImageCache[i],
								responseType: "file",
								success: (response) => {
									let fileUri = `${folderUri}/${i + 1}`;
									if (response.data) {
										file.move({
											srcUri: response.data,
											dstUri: fileUri,
											success: function () {
												console.log(`图片保存成功: ${fileUri}`);
												resolve();
											},
											fail: function (data, code) {
												reject(this.$t("offline.moveImageFailed", { code: code }));
											},
										});
									} else {
										reject(this.$t("offline.emptyImageData"));
									}
								},
								fail: (data, code) => {
									if (code === 28) {
										reject(this.$t("offline.downloadTimeoutFailed"));
									} else {
										reject(this.$t("offline.downloadFailed", { code: code }));
									}
								},
							});
						});
					} catch (error) {
						throw error;
					}
				}
			} else {
				await this.DownloadImage();
				for (let page = 1; page <= this.page_count; page++) {
					this.page = page;
					await this.downloadImage(page, folderUri);
				}
				for (let i = 0; i < ImageCache.length; i++) {
					this.page = i + 1;
					try {
						await new Promise((resolve, reject) => {
							fetch.fetch({
								url: ImageCache[i],
								responseType: "file",
								success: (response) => {
									let fileUri = `${folderUri}/${i + 1}`;
									if (response.data) {
										file.move({
											srcUri: response.data,
											dstUri: fileUri,
											success: function () {
												console.log(`图片保存成功: ${fileUri}`);
												resolve();
											},
											fail: function (data, code) {
												reject(this.$t("offline.moveImageFailed", { code: code }));
											},
										});
									} else {
										reject(this.$t("offline.emptyImageData"));
									}
								},
								fail: (data, code) => {
									if (code === 28) {
										reject(this.$t("offline.downloadTimeoutFailed"));
									} else {
										reject(this.$t("offline.downloadFailed", { code: code }));
									}
								},
							});
						});
					} catch (error) {
						throw error;
					}
				}
			}

			this.processing = true;
			await sleep(1000);
			this.loadingComic();
			this.dl = false;
			console.log("所有图片下载完成");
		} catch (error) {
			console.log(`下载过程出错: ${error}`);
			this.downloadError = error;
			this.processing = false;
		}
	},

	createFolder(folderUri) {
		return new Promise((resolve, reject) => {
			file.mkdir({
				uri: folderUri,
				success: function () {
					console.log(`文件夹创建成功: ${folderUri}`);
					resolve();
				},
				fail: function (data, code) {
					if (code === 13900001) {
						console.log("文件夹已存在");
						resolve();
					} else {
						reject(this.$t("offline.createFolderFailed", { code: code }));
					}
				},
			});
		});
	},

	downloadImage(page, folderUri, retryCount = 0) {
		let imageUrl;
		const MAX_RETRY = 3;

		return new Promise((resolve, reject) => {
			if (global.API_SETTING[global.API_SETTING.using].type === "jmcomic") {
				imageUrl =
					global.API_SETTING[global.API_SETTING.using].apiUrl +
					global.API_SETTING[global.API_SETTING.using].photoPath
						.replace("<id>", this.id)
						.replace("<page>", page);
			} else if (
				global.API_SETTING[global.API_SETTING.using].type === "ehentai"
			) {
				imageUrl = ehImageCache[page - 1];
				imageUrl = addImageParams(
					imageUrl,
					parseInt(global.APP_SETTING.imageSize) || 600,
					parseInt(global.APP_SETTING.imageQuality) || 50,
					["w", "q"]
				);
			} else {
				imageUrl = ImageCache[page - 1];
				imageUrl = addImageParams(
					imageUrl,
					parseInt(global.APP_SETTING.imageSize) || 600,
					parseInt(global.APP_SETTING.imageQuality) || 50
				);
			}

			const fileUri = `${folderUri}/${page}`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: function () {
								console.log(`图片保存成功: ${fileUri}`);
								resolve();
							},
							fail: function (data, code) {
								reject(this.$t("offline.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("offline.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(`下载图片失败, code = ${code}, retryCount = ${retryCount}`);
					
					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.downloadTimeout", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.networkErrorRetry", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadImage(page, folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("offline.downloadTimeoutFailed"));
						} else {
							reject(this.$t("offline.downloadFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	ehDownloadImage(page = 0, retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			const [gid, token] = this.id.split("_");

			fetch.fetch({
				url:
					global.API_SETTING[global.API_SETTING.using].apiUrl +
					global.API_SETTING[global.API_SETTING.using].photoPath
						.replace("<gid>", gid)
						.replace("<token>", token)
						.replace("<page>", page),
				success: async (response) => {
					const body = response.data;
					ehImageCache = [
						...ehImageCache,
						...body.images.map(
							(img) =>
								global.API_SETTING[global.API_SETTING.using].apiUrl +
								img.image_jpg
						),
					];
					if ((page + 1) * 20 <= this.page_count) {
						await this.ehDownloadImage(page + 1);
					}
					resolve();
				},
				fail: (data, code) => {
					console.log(`获取图片列表失败, code = ${code}, retryCount = ${retryCount}`);
					
					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.downloadTimeout", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.ehDownloadImage(page, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.networkErrorRetry", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.ehDownloadImage(page, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("offline.fetchListTimeoutFailed"));
						} else {
							reject(this.$t("offline.fetchListFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	DownloadImage(retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			fetch.fetch({
				url:
					global.API_SETTING[global.API_SETTING.using].apiUrl +
					global.API_SETTING[global.API_SETTING.using].photoPath
						.replace("<id>", this.id)
						.replace("<chapter>", this.chapter),
				success: async (response) => {
					const body = response.data;
					ImageCache = [...body.images.map((img) => img.url)];
					resolve();
				},
				fail: (data, code) => {
					console.log(`获取图片列表失败, code = ${code}, retryCount = ${retryCount}`);
					
					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.downloadTimeout", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.networkErrorRetry", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.DownloadImage(retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("offline.fetchListTimeoutFailed"));
						} else {
							reject(this.$t("offline.fetchListFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	downloadCover(folderUri, retryCount = 0) {
		const MAX_RETRY = 3;
		return new Promise((resolve, reject) => {
			let imageUrl;
			if (global.API_SETTING[global.API_SETTING.using].type === "jmcomic") {
				imageUrl = `${
					global.API_SETTING[global.API_SETTING.using].apiUrl
				}/album/${this.id}/cover`;
			} else {
				imageUrl = this.cover;
			}

			const fileUri = `${folderUri}/cover`;

			fetch.fetch({
				url: imageUrl,
				responseType: "file",
				success: (response) => {
					if (response.data) {
						file.move({
							srcUri: response.data,
							dstUri: fileUri,
							success: function () {
								console.log(`图片保存成功: ${fileUri}`);
								resolve();
							},
							fail: function (data, code) {
								reject(this.$t("offline.moveImageFailed", { code: code }));
							},
						});
					} else {
						reject(this.$t("offline.emptyImageData"));
					}
				},
				fail: (data, code) => {
					console.log(`下载封面失败, code = ${code}, retryCount = ${retryCount}`);
					
					if (code === 28 && retryCount < MAX_RETRY) {
						console.log(`网络超时，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.downloadTimeout", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else if (retryCount < MAX_RETRY) {
						console.log(`网络错误，正在重试第 ${retryCount + 1} 次...`);
						prompt.showToast({
							message: this.$t("offline.networkErrorRetry", { count: retryCount + 1 }),
							duration: 1500,
						});
						sleep(1000).then(() => {
							this.downloadCover(folderUri, retryCount + 1)
								.then(resolve)
								.catch(reject);
						});
					} else {
						if (code === 28) {
							reject(this.$t("offline.coverTimeoutFailed"));
						} else {
							reject(this.$t("offline.coverFailed", { code: code }));
						}
					}
				},
			});
		});
	},

	toPhoto(val) {
		router.push({
			uri: "/pages/photo",
			params: {
				id: val.id,
				page_count: val.page_count,
				local: true,
			},
		});
	},

	del(id) {
		if (id != del) {
			del = id;
			prompt.showToast({
				message: this.$t("offline.del"),
				duration: 2000,
			});
		} else {
			prompt.showToast({
				message: this.$t("offline.secondDel"),
				duration: 1000,
			});
			
			const folderUri = "internal://files/" + id + "/";
			
			file.access({
				uri: folderUri,
				success: () => {
					file.rmdir({
						uri: folderUri,
						recursive: true,
						success: () => {
							this.updateComicsIndex(id);
						},
						fail: (data, code) => {
							console.log(`删除文件夹失败, code = ${code}`);
							prompt.showToast({
								message: this.$t("offline.deleteFailed", { code: code }),
								duration: 2000,
							});
						},
					});
				},
				fail: () => {
					console.log(`文件夹不存在，直接删除索引`);
					this.updateComicsIndex(id);
				},
			});
		}
	},

	updateComicsIndex(id) {
		file.readText({
			uri: "internal://files/comics.json",
			success: (data) => {
				try {
					let comicsData = [];
					if (data.text) {
						comicsData = JSON.parse(data.text);
					}

					const existingIndex = comicsData.findIndex(
						(comic) => comic.id === id
					);

					if (existingIndex !== -1) {
						comicsData.splice(existingIndex, 1);
					}

					file.writeText({
						uri: "internal://files/comics.json",
						text: JSON.stringify(comicsData),
						success: () => {
							console.log("comics.json更新成功");
							prompt.showToast({
								message: this.$t("offline.delComplete"),
								duration: 1000,
							});
							this.loadingComic();
						},
						fail: (data, code) => {
							console.log(`写入comics.json失败, code = ${code}`);
							prompt.showToast({
								message: this.$t("offline.indexUpdateFailed"),
								duration: 2000,
							});
							this.loadingComic();
						},
					});
				} catch (parseError) {
					console.log(`解析comics.json失败: ${parseError}`);
					prompt.showToast({
						message: this.$t("offline.indexReadFailed"),
						duration: 2000,
					});
					this.loadingComic();
				}
			},
			fail: (data, code) => {
				console.log(`读取comics.json失败, code = ${code}`);
				prompt.showToast({
					message: this.$t("offline.indexNotExist"),
					duration: 2000,
				});
				this.loadingComic();
			},
		});
	},

	toggleStorageList() {
		this.storageListExpanded = !this.storageListExpanded;
	},

	routeBack() {
		router.back();
	},
};
</script>

<style>
@import "../../common/base.css";

.container {
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
}

.storage-container {
	width: 85%;
	flex-direction: column;
	align-items: center;
	padding: 10px 20px;
	background-color: #262626;
	border-radius: 24px;
	margin-top: 10px;
}

.storage-label {
	font-size: 24px;
	color: rgba(255, 255, 255, 0.8);
	font-weight: bold;
	margin-bottom: 8px;
}

.storage-bar {
	width: 100%;
	height: 12px;
	background-color: rgba(255, 255, 255, 0.2);
	border-radius: 6px;
	overflow: hidden;
	margin-bottom: 8px;
	display: flex;
	flex-direction: row;
}

.storage-bar-segment {
	height: 100%;
	display: flex;
	border-radius: 6px;
	flex-direction: row;
	align-items: center;
}

.storage-bar-segment-reserved {
	background-color: rgba(255, 255, 255, 0.3);
	border-right: 1px solid rgba(255, 255, 255, 0.1);
}

.storage-bar-segment-comics {
	background-color: #4CAF50;
	border-right: 1px solid rgba(255, 255, 255, 0.1);
}

.storage-bar-segment-other {
	background-color: rgba(76, 175, 80, 0.3);
}

.storage-list {
	width: 100%;
	flex-direction: column;
}

.storage-list-item {
	width: 100%;
	flex-direction: row;
	align-items: center;
	padding: 6px 0;
	justify-content: space-between;
}

.storage-list-color {
	width: 12px;
	height: 12px;
	border-radius: 3px;
	margin-right: 8px;
}

.storage-list-color-reserved {
	background-color: rgba(255, 255, 255, 0.3);
}

.storage-list-color-comics {
	background-color: #4CAF50;
}

.storage-list-color-other {
	background-color: rgba(76, 175, 80, 0.3);
}

.storage-list-color-remaining {
	background-color: rgba(255, 255, 255, 0.1);
}

.storage-list-label {
	font-size: 20px;
	color: rgba(255, 255, 255, 0.6);
	flex: 1;
}

.storage-list-value {
	font-size: 20px;
	color: rgba(255, 255, 255, 0.8);
	font-weight: bold;
}

.storage-list-arrow {
	font-size: 16px;
	font-family: "iconfont" !important;
    font-style: normal;
	color: rgba(255, 255, 255, 0.8);
	margin-left: 4px;
}

.storage {
	text-align: center;
	font-size: 24px;
	color: #ffffff;
	font-weight: bold;
}

.text-content {
	width: 186px;
	height: 100%;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	margin-left: 10px;
}

.meta {
	font-size: 18px;
	font-weight: bold;
	color: rgba(255, 255, 255, 0.7);
}

/* 看看是不是红米手表 */
@media (shape: rect) {
	#process {
		position: absolute;
		bottom: 6px;
		width: 95%;
		height: 92px;
		background-color: #262626;
		border-radius: 36px;
		justify-content: space-around;
	}

	.downloading,
	.empty {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex: 1;
		flex-direction: column;
	}
}

.content {
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
}

.per {
	font-size: 32px;
	color: rgba(255, 255, 255, 0.6);
	font-weight: bold;
}

.dl-text {
	margin-top: 24px;
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
	margin-bottom: 80px;
}

.empty-text {
	margin-top: 24px;
	font-size: 32px;
	color: #ffffff;
	font-weight: bold;
}

.box {
	width: 85%;
	flex: 1
}

.item {
	height: 120px;
	width: 100%;
	background-color: #262626;
	border-radius: 24px;
	padding: 10px;
	align-items: center;
	justify-content: space-around;
	margin-bottom: 10px;
}

.itemText {
	width: 100%;
	height: 100%;
	font-size: 24px;
	color: #ffffff;
	lines: 3;
	font-weight: bold;
}

.cover {
	height: 96px;
	width: 92px;
}

/* 看看是不是小米手表 */
@media (min-width: 200) and (max-width: 235) and (shape: circle) {
	.storage-container {
		width: 75%;
	}

	#process {
		position: absolute;
		width: 80%;
		height: 92px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}

	#process-s4 {
		position: absolute;
		width: 80%;
		padding: 10px 25px;
		background-color: #262626;
		border-radius: 100%;
		justify-content: space-around;
	}

	.container {
		justify-content: center;
	}

	.downloading {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex-direction: column;
		position: absolute;
		bottom: 40px;
	}

	.empty {
		justify-content: center;
		align-items: center;
		width: 100%;
		flex-direction: column;
	}

	.title {
		position: absolute;
		top: 35px;
	}

	.time {
		position: absolute;
		top: 7px;
	}

	#mask {
		position: absolute;
		top: 100px;
	}

	.dl-text {
		margin-top: 24px;
		font-size: 32px;
		color: #ffffff;
		font-weight: bold;
		margin-bottom: 20px;
	}

	.box {
		width: 75%;
	}
}
</style>
